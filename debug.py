#encoding=utf-8
# while True:
#     try:
#         T = int(input())
#         n = int(input())
#         values = list(map(int, input().split()))
        
#         def helper(arr,remain, index):
            
#             if remain == 0:
#                 return True
#             if index < len(arr) and remain < arr[index]:
#                 return False

#             for i in range(index, len(arr)):
#                 if remain - arr[i] >= 0:
#                     if helper(arr, remain-arr[i], i+1):
#                         return True
#             return False
#             pass
#             # if 
        
#         reng = []
        
#         queue = [(values,0)]
#         while queue:
#             # reng.append(values[i])
#             cur, index = queue.pop(0)
#             # cur = sorted(cur,reverse=True)
#             if sum(cur) %2 == 0 and helper(cur, sum(cur)//2, 0):
#                 # print(cur)
#                 break
            
#             for i in range(index, len(cur)):
#                 # if sum(cur[:i]+cur[i+1:]) % 2 != 0:
#                 #     continue
                
#                 queue.append((cur[:i]+cur[i+1:], i))
#             # reng.pop()

#         for remain in cur:
#             values.pop(values.index(remain))
#         print(sum(values))
        

        
#     except:
#         break
# A = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]
# def shortestBridge(A):
    
#     from collections import deque
#     def bfs(source):
#         d_Que = deque()
#         d_Que.extend([(i,j,-1) for i,j in source])
#         # visit = set(source)
        
#         while d_Que:
#             i, j, depth = d_Que.popleft()
            
#             if A[i][j] == 1:
#                 return depth
            
#             # A[i][j] = 2
            
#             for x,y in [(-1,0),(1,0),(0,1),(0,-1)]:
#                 newi = i+x
#                 newj = j+y
#                 if newi < 0 or newi >= len(A) or newj < 0 or newj >= len(A[0]) or A[newi][newj] == 2:
#                     continue
#                 if A[newi][newj] == 1:
#                     return depth+1
#                 d_Que.append((newi, newj, depth+1))
#                 A[newi][newj] = 2
#                 # visit.add((newi, newj))

#     def dfs(source, i,j):
#         # nonlocal source
#         A[i][j] = 2
        
#         for x,y in [(-1,0),(1,0),(0,1),(0,-1)]:
#             newi, newj = i+x, j+y
#             if newi < 0 or newi >= len(A) or newj < 0 or newj >= len(A[0]) or A[newi][newj] == 0:
#                 continue
#             if (newi, newj) in source:
#                 continue
#             source.add((newi,newj))
#             dfs(source, newi, newj)

#         pass

#     source = set()
#     for i in range(len(A)):
#         for j in range(len(A[0])):
#             if A[i][j] != 0:
#                 source.add((i,j))
#                 dfs(source, i, j)
#                 return bfs(source)
# print(shortestBridge(A))

# #coding=utf-8
# import sys 
# #str = input()
# #print(str)
# N = 2
# stack = 0
# ret = []
# def helper(stack, res):
#     # edge case
#     #global ret
#     if len(res) == 2*N:
#         if stack == 0:
#             ret.append(res[:])
#         return 

    
#     for char in ['(',')']:
#         if char == '(':
#             stack += 1
#         else:
#             stack -= 1
#         if stack > N:
#             stack -= 1
#             continue
#         if stack >= 0:
#             res += char
#             helper(stack, res)
#             res = res[:-1]
        
#     pass

# helper(0, "")
# print(ret)

# while True:
#     try:
#         string = input()
#         dp = [[False]*len(string) for _ in range(len(string))]
#         res = ""
#         res = 0
#         s = string
#         for i in range(len(string)-1,-1,-1):
#             for j in range(i+1,len(string)):
                
#                 if j - i + 1 & 1 == 1:
#                     continue
#                 if j - i == 1:
#                     if s[i] == s[j]:
#                         dp[i][j] = True
#                         if j - i + 1 > res:
#                             res = j - i + 1
#                             ret = s[i:j+1]
#                         continue
#                 elif j - i > 1:
#                     if s[i] == s[j]:
#                         dp[i][j] = dp[i+1][j-1]
#                         if j - i + 1 > res:
#                             res = j - i + 1
#                             ret = s[i:j+1]
#                         continue
#         print(ret)
        
#     except:
#         break
# while True:
#     try:
#         T = int(input())
#         for _ in range(T):
#             res = 'YES'
#             ll = input().split()
#             fenzu = [set() for _ in range(3)]
#             paizu = [set() for _ in range(3)]
#             for pai in ll:
#                 num = pai[0]
#                 char = pai[1]
#                 if num in ['1', '4', '7']:
#                     if num+char in fenzu[0]:
#                         res = 'NO'
#                         break
#                     if paizu[0] and char not in paizu[0]:
#                         res = 'NO'
#                         break
#                     fenzu[0].add(num+char)
#                     paizu[0].add(char)
#                 elif num in ['2', '5', '8']:
#                     if num+char in fenzu[1]:
#                         res = 'NO'
#                         break
#                     if paizu[1] and char not in paizu[1]:
#                         res = 'NO'
#                         break
#                     fenzu[1].add(num+char)
#                     paizu[1].add(char)
#                 else:
#                     if num+char in fenzu[0]:
#                         res = 'NO'
#                         break
#                     if paizu[2] and char not in paizu[2]:
#                         res = 'NO'
#                         break
#                     fenzu[2].add(num+char)
#                     paizu[2].add(char)
            
#             string = ""
#             for i in paizu:
#                 string += i.pop()
#             if sorted(string) != sorted('WBT'):
#                 res = 'NO'
                    


#             print(res)
#         pass

#     except:
#         pass

# T = int(input())
# n_line = int(input())
# stack = []
# time = 0
# res = 0
# ret_time = {}
# for _ in range(n_line):
#     t, id, state = list(map(int, input().split()))
#     if stack:
#         if state == 0:
#             stack.append([id, t, 0])
            
#         elif state == 1: #出栈
#             out_id, out_t, _= stack.pop()
#             res_t = t - out_t #计算当前任务的时间跨度
#             if res_t > res:
#                 res = res_t
#                 ret = out_id
#             for i in stack:
#                 i[1] += res_t

#     else:# 只能进站
#         stack.append([id, t, 0])


# print(ret)

# 4
# 1T 4T 7T 2B 5B 8B 9W
# 1T 2T 3T 4T 5T 6T 7T
# 1B 2W 3T 4B 5W 6T 8W
# 2B 8B 5B 2B 6T 7W 4W


# s = "abbaabbbbababaababababbabbbaaaabbbbaaabbbabaabbbbbabbbbabbabbaaabaaaabbbbbbaaabbabbbbababbbaaabbabbabb"
# p = "***b**a*a*b***b*a*b*bbb**baa*bba**b**bb***b*a*aab*a**"
# s = s[1:-1]
# p = p[1:-1]
# def build(p):
#     dic = {}
#     state = 1
#     for i in range(len(p)):
#         asc = ord(p[i])
#         if (asc >= 97 and asc <= 97+25) or p[i] == '?':
#             dic.setdefault(state, {}).update({p[i] : state+1}) #匹配当前这个字符或者？可以到达下一个状态
#         elif p[i] == '*': 
#             if i-1>=0 and p[i-1] == '*':
#                 continue
#             dic.setdefault(state, {}).update({'*' : state}) #*可以匹配任意字符，回到自身状态
#             dic.setdefault(state, {}).update({'$' : state + 1}) #可以匹配空字符到达下一个状态
#         state += 1
#     dic[state] = {} #最后进入空状态
#     return dic         
#     pass

# dfa = build(p)

# def dfs(state, charidx):
    
#     if charidx == len(s): #如果字符没了
#         if state == 41:
#             pass
#             print('1')
#         if not dfa[state]: #进入了空状态
#             return True
#         if '$' in dfa[state]: #进行空转移
#             if dfs(dfa[state]['$'], charidx): #空转移后成功
#                 return True
#             else: #空转移后失败
#                 return False
        
#         #对于一个空字符，没有进入空状态，也没有空转移可进入，则失败
#         return False
            
#     char = s[charidx]
#     pattern = dfa[state]
#     for pt in pattern.keys():
#         if pt == '?' or pt == char or pt == '*':
#             if dfs(pattern[pt], charidx+1):
#                 return True
        
#         elif pt == '$': #*匹配了0个字符
#             if dfs(pattern[pt], charidx):
#                 return True
#     return False
#     pass
# print(dfs(1, 0))


# while True:
#     try:
#         from collections import defaultdict
#         hashmapa = defaultdict(int)
#         hashmapb = defaultdict(int)
#         stringa = input()
#         stringb = input()
#         for i in range(len(stringa)):
#             hashmapa[stringa[i]] += 1
#         for i in range(len(stringb)):
#             hashmapb[stringb[i]] += 1

#         res = True
#         for k, v in hashmapa.items():
#             if k not in hashmapb:
#                 res = False
#                 break
#             if v != hashmapb[k]:
#                 res = False
#                 break
#             hashmapb.pop(k)

#         if not res:
#             print(0)
#         else:
#             if not hashmapb:
#                 print(1)
#             else:
#                 print(0)

#     except:
#         break

# while True:
#     try:
#         n, m = list(map(int, input().split()))  # n : 物品数量, m : 重量限制
#         W = [0]
#         V = [0]
#         for i in range(n):
#             w, v = list(map(int, input().split()))
#             W.append(w)  # 物品的重量
#             V.append(v)  # 物品的价值

#         # dp[i][j] 面临第i个物品,剩余重量j时能获得的最大奖励值
#         dp = [[0] * (m+1) for _ in range(n+1)]

#         for i in range(1, n+1):
#             for j in range(m+1):
#                 if j == 0: #如果剩余重量为0
#                     dp[i][j] = 0

#                 elif j >= W[i]: # 当可选第i个物品时
#                     dp[i][j] = max(dp[i][j], dp[i-1][j-W[i]] + V[i], dp[i-1][j])  # 选了第i个物品
#                 else:
#                     dp[i][j] = max(dp[i][j], dp[i-1][j])  # 不选第i个物品

#         print(dp[n][m])
#         pass

#     except:
#         break


# while True:
#     try:
#         def valid(n):
#             if n == 2:return True
#             for i in range(2,n):
#                 if n % i == 0:
#                     return False
#             return True
#         num = int(input())
#         res = 0
#         nums = []
#         for i in range(2,num+1):
#             if valid(i):
#                 nums.append(i)
#         l = 0
#         r = 0
#         while r != len(nums):
#             sumv = sum(nums[l:r+1])
#             if sumv == num:
#                 res += 1
#                 l += 1
#             elif sumv > num:
#                 l += 1
#             elif sumv < num:
#                 r += 1
#             pass
#         print(res)
        

#     except:
#         break        

# n, m = list(map(int, input().split()))
# v = [0]*n
# w = [0]*n
# sumv = [[i,0] for i in range(1,n+1)]
# for i in range(n):
#     v[i], w[i] = list(map(int, input().split()))
#     sumv[i][-1] = v[i] + 2*w[i]
# sumv = sorted(sumv, reverse=True, key=lambda x: x[1])
# res = []
# for i in range(m):
#     res.append(sumv[i][0])
# res = sorted(res)
# ret = ' '.join([str(x) for x in res])
# print(ret)


# n, k = [int(i) for i in input().strip().split()]
# graph = {}
# for i in range(n - 1):
#     node_a, node_b = [int(i) for i in input().strip().split()]
#     if node_a - 1 not in graph:
#         graph[node_a - 1] = []
#     if node_b - 1 not in graph:
#         graph[node_b - 1] = []
#     graph[node_a - 1].append(node_b - 1)
#     graph[node_b - 1].append(node_a - 1)

# level = [int(i) for i in input().strip().split()]
# visited = [False] * n

# res = set()


# def dfs(graph, level, k, maxLevel, minLevel, visited, node, res, lastRegion):
#     maxLevel = max(maxLevel, level[node])
#     minLevel = min(minLevel, level[node])
#     lastRegion = sorted(lastRegion)
#     if maxLevel - minLevel > k or tuple(lastRegion) in res:
#         return

#     res.add(tuple(lastRegion))
#     for i in graph.get(node, []):
#         if not visited[i]:
#             visited[i] = True
#             dfs(graph, level, k, maxLevel, minLevel,
#                 visited, i, res, lastRegion + [i])
#             visited[i] = False


# for i in graph.keys():
#     visited[i] = True
#     dfs(graph, level, k, level[i], level[i], visited, i, res, [i])
#     visited[i] = False

# print(len(res) % (10 ** 9 + 7))


#字节跳动两道题
# 第二题
# fac = [0]*200000
# mod = 10**9+7
# cnt = [0]*2000
# fac[0] = 1
# for i in range(1,100000+1):
#     fac[i] = fac[i-1]*2%mod
# n, k = list(map(int, input().split()))
# a = list(map(int, input().split()))
# for i in range(n):
#     cnt[a[i]%k] += 1
# sumv = 1
# for i in range(1,k):
#     tmp = fac[cnt[i]] #假设mod k = i的数字构成集合X,则tmp=集合X的所有子集个数
#     j = k - i
#     if j < i: 
#         break
#     if j != i:
#         # mod k = i的所有集合X + mod k = j(j=k-i)的所有集合Y,求并集.
#         #集合X和集合Y中的任意元素不能交叉的放在一起,因为那样会导致和被k整除
#         tmp = (tmp+fac[cnt[j]])%mod 
#         tmp = (tmp-1+mod)%mod #去掉上面重复计算的空集
#     else:
#         tmp = (cnt[j]+1) % mod #如果i=j, 2*i=k, 因此mod k = i的集合X中的元素不能组合在一起,必须单独成为子序列,再加上一个空集
#     sumv = (sumv*tmp)%mod

# sumv *= (cnt[0]+1)%mod  #上面那些mod k = 1,2,....k-1的所有集合,再加入一个mod k = 0的数仍然符合条件.
#                         # 上面计数中只会产生一个空集,该空集和mod k = 0的数组成非空集,因此最终的空集需要上面的空集和这里的空集组成
# sumv = (sumv%mod+mod)%mod
# print(sumv)
    
# # 第一题
# # 题意：
# # 给定 n l r
# # 求长度为n的 且元素在[l-r] 的 且 数组元素和是3的倍数的 数组的 个数

# # 思路：
# # DP
# # mod0 表示区间内的数mod 3 = 0的个数 mod1 mod2 同理
# # dp[i][j] 表示 长度为i的 数组元素mod 3 为 j 的数组的个数
# # 如果 i-1长度的数组和 mod 3 = 0 那么我再加一个 mod 3 = 0的数 整个数组 mod 3 还是等于0
# # 如果 i-1长度的数组和 mod 3 = 1 那么我再加一个 mod 3 = 2 的数 整个数组 mod 3 就等于0了
# # 如果 i-1长度的数组和 mod 3 = 2 那么我再加一个 mod 3 = 1 的数 整个数组 mod 3 就等于0了
# # 也就是 dp[i][0] = dp[i-1][0]*mod0+dp[i-1][1]*mod2+dp[i-1][2]*mod1
# # 剩下两个同理
# # 那么转移方程：
# n, l, r = map(int, input().split())
# dp = [[0, 0, 0] for i in range(n)]
# mod = 1000000007
# mod0 = (r//3-(l-1)//3) % mod
# mod1 = ((r+2)//3-(l+1)//3) % mod
# mod2 = ((r+1)//3-(l)//3) % mod
# dp[0][0] = mod0
# dp[0][1] = mod1
# dp[0][2] = mod2
# print(mod1, mod2, mod0)
# for i in range(1, n):
#     dp[i][0] = ((dp[i-1][0]*mod0) % mod+(dp[i-1][1]*mod2) %mod+(dp[i-1][2]*mod1) % mod) % mod
#     dp[i][1] = ((dp[i-1][0]*mod1) % mod+(dp[i-1][1]*mod0) %
#                 mod+(dp[i-1][2]*mod2) % mod) % mod
#     dp[i][2] = ((dp[i-1][0]*mod2) % mod+(dp[i-1][1]*mod1) %
#                 mod+(dp[i-1][2]*mod0) % mod) % mod
# print(dp[n-1][0])



#京东
# class TreeNode:
#     def __init__(self):
#         self.childptr = [0]*26

# n = int(input().strip())
# mat = []
# dp = []
# for i in range(n):
#     mat.append(list(map(int, input().strip().split())))
#     dp.append([0] * len(mat[-1]))
# dp[0][0] = mat[0][0]
# for i in range(1, n):
#     for j, s in enumerate(dp[i]):
#         span = [x for x,_ in enumerate(dp[i-1]) if j-2 <= x <= j]
#         for x in span:
#             dp[i][j] = max(dp[i][j], mat[i][j]+dp[i-1][x])
# print(max(dp[-1]))




# class Solution:
#     def get_letters(self , input_num_list ):
#         # write code here
# input_num_list = [0,1,9]
# umap = {0:'abc', 1:'def', 2:'ghi', 3:'jkl', 4:'mno', 5:'pqr', 6:'stu',7:'vwx',8:'y',9:'z'}
# def dfs(string, arr):
#     global res
#     if not arr:
#         res.append(string)
#         return 
#     for char in umap[arr[0]]:
#         string += char
#         dfs(string, arr[1:])
#         string = string[:-1]
#     pass

# res = []
# dfs('', input_num_list)
# print(res)


# n, m = [int(i) for i in input().strip().split()]
# a = [int(i) for i in input().strip().split()]
# p = [int(i) for i in input().strip().split()]

# ptr = 0
# res = 0 #价格
# rem = 0 #剩余糖
# while ptr < n:
#     k = 0
#     cnt = 0
#     while ptr+k < n and a[ptr+k] >= a[ptr]:
#         cnt += a[ptr+k] #糖需求量
#         k += 1
#     cnt -= rem #去掉上一轮已有糖
#     rem = cnt % m
#     res += p[ptr]*((cnt+m-1)//m)
#     ptr += k
    
# print(res)


        
# n, m = [int(i) for i in input().strip().split()]
# a = [int(i) for i in input().strip().split()]
# p = [int(i) for i in input().strip().split()]

# ptr = 1
# res = 0  # 总价格
# rem = a[0]  # 剩余待买的糖
# minn = p[0]
# last = 0
# while ptr < n:
#     if p[ptr] < minn:
#         if last < rem:
#             num = (rem-last+m-1)//m
#             last = num*m-rem+last
#             res += num*minn
#         else:
#             last -= rem
#         minn = p[ptr]
#         rem = a[ptr]
#     else:
#         rem += a[ptr]
#     ptr += 1
# if last < rem:
#    num = (rem-last+m-1)//m
#    res += num*minn
# print(res)


# #!/bin/python
# # -*- coding: utf8 -*-
# import sys
# import os
# import re

# #请完成下面这个函数，实现题目要求的功能
# #当然，你也可以不按照下面这个模板来作答，完全按照自己的想法来 ^-^ 
# #******************************开始写代码******************************


# def  longestValidParenthe(s):
#     dp = [0] * len(s)
#     if len(s) < 2:
#         return 0
#     if s[1] == ')' and s[0] == '(':
#         dp[1] =2
#     if len(s) == 2:
#         return dp[1]
#     for i in range(2, len(s)):
#         if s[i] == '(':
#             dp[i] = 0
#             continue
#         if s[i] == ')':
#             if s[i-1] == '(':
#                 dp[i] = dp[i-2] + 2
#             elif s[i-1] == ')' and s[i-1-dp[i-1]] == '(' and i-1-dp[i-1] >= 0:
#                 dp[i] = dp[i-1-dp[i-1]-1]+2+dp[i-1]
#     return max(dp)
    
        
            
        


# #******************************结束写代码******************************


# try:
#     _s = input()
# except:
#     _s = None

  
# res = longestValidParenthe(_s)

# print(str(res) + "\n")

# #!/bin/python
# # -*- coding: utf8 -*-
# import sys
# import os
# import re

# #请完成下面这个函数，实现题目要求的功能
# #当然，你也可以不按照下面这个模板来作答，完全按照自己的想法来 ^-^
# #******************************开始写代码******************************


# def findNumber(num):
#     def helper1(num):
#         a,b =0,0
#         n = num
#         while n&1 == 0 and n !=0:
#             a += 1
#             n>>=1
#         while n&1 == 1:
#             b += 1
#             n >>= 1
#         if a+b == 31 or a+b == 0:
#             return -1
#         c = a+b
#         num |= (1<<c)
#         num &= ~((1<<c) -1)
#         num |= (1<<(b-1))-1
#         return num

#     def helper2(num):
#         a, b = 0, 0
#         n = num
#         while n & 1 == 1:
#             b += 1
#             n >>= 1
#         if n == 0:
#             return -1
#         while n&1 == 0 and n != 0:
#             a+=1
#             n >>= 1
            
#         c = a+b
#         num &= ((~0) <<(c+1))
#         m = (1<<(b+1))-1
#         num |= m<<(a-1)
        
#         return num
#     return [helper1(num),helper2(num)]
#     # return [helper1(num)]
#     #******************************结束写代码******************************


# _num = int(input())


# res = findNumber(_num)

# for res_cur in res:
#     print(str(res_cur) + "\n")

    
                
            
